/*
 * Copyright (C) 2018 Eddie Antonio Santos <easantos@ualberta.ca>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

(function () {
  'use strict'

  // EXPORT: version
  const VERSION = '2020.12.11'

  // What functions and constants to export:
  let exports = {
    sro2syllabics: sro2syllabics,
    syllabics2sro: syllabics2sro,
    version: VERSION
  }

  // ============================ Constants ============================ \\

  // Default options for sro2syllabics() and syllabics2sro
  const DEFAULT_SRO2SYLLABICS_OPTIONS = {
    hyphens: '\u202f', // U+202F NARROW NO-BREAK SPACE, preferred by syllabics writers
    finalHK: 'x', // by default use ·ïΩ as the word-final hk. Maskwac√Æs uses ·ê¶·ê† instead.
  }
  const DEFAULT_SYLLABICS2SRO_OPTIONS = {
    longAccents: 'circumflexes'
  }

  // Word and syllable matching regular expressions.
  // NOTE: autogenerated by ./libexec/generate-regexp.py
  const sroPattern = /((?:[ptkcshmnyw]|th)w?)-([\u00EAioa\u00EE\u00F4\u00E2])|th\u00EA|thi|tho|tha|th\u00EE|th\u00F4|th\u00E2|thw\u00EA|thwi|thwo|thwa|thw\u00EE|thw\u00F4|thw\u00E2|th|w\u00EA|wi|wo|wa|w\u00EE|w\u00F4|w\u00E2|w|p\u00EA|pi|po|pa|p\u00EE|p\u00F4|p\u00E2|pw\u00EA|pwi|pwo|pwa|pw\u00EE|pw\u00F4|pw\u00E2|p|t\u00EA|ti|to|ta|t\u00EE|t\u00F4|t\u00E2|tw\u00EA|twi|two|twa|tw\u00EE|tw\u00F4|tw\u00E2|t|k\u00EA|ki|ko|ka|k\u00EE|k\u00F4|k\u00E2|kw\u00EA|kwi|kwo|kwa|kw\u00EE|kw\u00F4|kw\u00E2|k|c\u00EA|ci|co|ca|c\u00EE|c\u00F4|c\u00E2|cw\u00EA|cwi|cwo|cwa|cw\u00EE|cw\u00F4|cw\u00E2|c|m\u00EA|mi|mo|ma|m\u00EE|m\u00F4|m\u00E2|mw\u00EA|mwi|mwo|mwa|mw\u00EE|mw\u00F4|mw\u00E2|m|n\u00EA|ni|no|na|n\u00EE|n\u00F4|n\u00E2|nw\u00EA|nwa|nw\u00E2|n|s\u00EA|si|so|sa|s\u00EE|s\u00F4|s\u00E2|sw\u00EA|swi|swo|swa|sw\u00EE|sw\u00F4|sw\u00E2|s|y\u00EA|yi|yo|ya|y\u00EE|y\u00F4|y\u00E2|yw\u00EA|ywi|ywo|ywa|yw\u00EE|yw\u00F4|yw\u00E2|y|h|l|r|\u00EA|i|\u00EE|o|\u00F4|a|\u00E2|-/
  // Since JavaScript engines I want to support (e.g., Safari, IE11) don't
  // support negative lookbehind, I caputre the "lookbehind" in the word
  // pattern, only to glue it together again later.
  const wordPattern = /(?:^|([^a-z\u00EA\u00EE\u00F4\u00E2\u0113\u012B'\u2019\u014D\u0101]))((?:(?:[ptkcmnsyh]|th)w?|[rl]|w|)(?:[\u00EAioa\u00EE\u00F4\u00E2]|[e\u0113\u012B'\u2019\u014D\u0101])(?:(?:(?:[hsmnwy]|th)?(?:[ptkcmnsyh]|th)w?|w|[yw]?[rl])(?:[\u00EAioa\u00EE\u00F4\u00E2]|[e\u0113\u012B'\u2019\u014D\u0101]))*(?:[hs]?(?:[ptcksmnwy]|th)|h|kw|[yw]?[rl]|)(?:(?:th|[hs]?[ptkcmn]|h|s|y|w)?-(?:(?:[ptkcmnsyh]|th)w?|[rl]|w|)(?:[\u00EAioa\u00EE\u00F4\u00E2]|[e\u0113\u012B'\u2019\u014D\u0101])(?:(?:(?:[hsmnwy]|th)?(?:[ptkcmnsyh]|th)w?|w|[yw]?[rl])(?:[\u00EAioa\u00EE\u00F4\u00E2]|[e\u0113\u012B'\u2019\u014D\u0101]))*(?:[hs]?(?:[ptcksmnwy]|th)|h|kw|[yw]?[rl]|))*)(?:(?=[^a-z\u00EAioa\u00EE\u00F4\u00E2e\u0113\u012B'\u2019\u014D\u0101])|$)/gi
  const fullStopPattern = /([\u1400-\u167F])[.]|^[.]$/g
  const finalDotPattern = /([\u1401\u1403\u1404\u1405\u1406\u140A\u140B\u142F\u1431\u1432\u1433\u1434\u1438\u1439\u144C\u144E\u144F\u1450\u1451\u1455\u1456\u146B\u146D\u146E\u146F\u1470\u1472\u1473\u1489\u148B\u148C\u148D\u148E\u1490\u1491\u14A3\u14A5\u14A6\u14A7\u14A8\u14AA\u14AB\u14C0\u14C7\u14C8\u14ED\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1526\u1528\u1529\u152A\u152B\u152D\u152E])\u1427/g

  // Lookup tables:
  const sro2syllabicsLookup = { '√™': '·êÅ', 'i': '·êÉ', '√Æ': '·êÑ', 'o': '·êÖ', '√¥': '·êÜ', 'a': '·êä', '√¢': '·êã', 'w√™': '·êç', 'wi': '·êè', 'w√Æ': '·êë', 'wo': '·êì', 'w√¥': '·êï', 'wa': '·êò', 'w√¢': '·êö', 'w': '·ê§', 'p': '·ëä', 'p√™': '·êØ', 'pi': '·ê±', 'p√Æ': '·ê≤', 'po': '·ê≥', 'p√¥': '·ê¥', 'pa': '·ê∏', 'p√¢': '·êπ', 'pw√™': '·êª', 'pwi': '·êΩ', 'pw√Æ': '·êø', 'pwo': '·ëÅ', 'pw√¥': '·ëÉ', 'pwa': '·ëÖ', 'pw√¢': '·ëá', 't': '·êü', 't√™': '·ëå', 'ti': '·ëé', 't√Æ': '·ëè', 'to': '·ëê', 't√¥': '·ëë', 'ta': '·ëï', 't√¢': '·ëñ', 'tw√™': '·ëò', 'twi': '·ëö', 'tw√Æ': '·ëú', 'two': '·ëû', 'tw√¥': '·ë†', 'twa': '·ë¢', 'tw√¢': '·ë§', 'k': '·ê†', 'k√™': '·ë´', 'ki': '·ë≠', 'k√Æ': '·ëÆ', 'ko': '·ëØ', 'k√¥': '·ë∞', 'ka': '·ë≤', 'k√¢': '·ë≥', 'kw√™': '·ëµ', 'kwi': '·ë∑', 'kw√Æ': '·ëπ', 'kwo': '·ëª', 'kw√¥': '·ëΩ', 'kwa': '·ëø', 'kw√¢': '·íÅ', 'c': '·ê®', 'c√™': '·íâ', 'ci': '·íã', 'c√Æ': '·íå', 'co': '·íç', 'c√¥': '·íé', 'ca': '·íê', 'c√¢': '·íë', 'cw√™': '·íì', 'cwi': '·íï', 'cw√Æ': '·íó', 'cwo': '·íô', 'cw√¥': '·íõ', 'cwa': '·íù', 'cw√¢': '·íü', 'm': '·íº', 'm√™': '·í£', 'mi': '·í•', 'm√Æ': '·í¶', 'mo': '·íß', 'm√¥': '·í®', 'ma': '·í™', 'm√¢': '·í´', 'mw√™': '·í≠', 'mwi': '·íØ', 'mw√Æ': '·í±', 'mwo': '·í≥', 'mw√¥': '·íµ', 'mwa': '·í∑', 'mw√¢': '·íπ', 'n': '·ê£', 'n√™': '·ìÄ', 'ni': '·ìÇ', 'n√Æ': '·ìÉ', 'no': '·ìÑ', 'n√¥': '·ìÖ', 'na': '·ìá', 'n√¢': '·ìà', 'nw√™': '·ìä', 'nwa': '·ìå', 'nw√¢': '·ìé', 's': '·ê¢', 's√™': '·ì≠', 'si': '·ìØ', 's√Æ': '·ì∞', 'so': '·ì±', 's√¥': '·ì≤', 'sa': '·ì¥', 's√¢': '·ìµ', 'sw√™': '·ì∑', 'swi': '·ìπ', 'sw√Æ': '·ìª', 'swo': '·ìΩ', 'sw√¥': '·ìø', 'swa': '·îÅ', 'sw√¢': '·îÉ', 'y': '·ê©', 'y√™': '·î¶', 'yi': '·î®', 'y√Æ': '·î©', 'yo': '·î™', 'y√¥': '·î´', 'ya': '·î≠', 'y√¢': '·îÆ', 'yw√™': '·î∞', 'ywi': '·î≤', 'yw√Æ': '·î¥', 'ywo': '·î∂', 'yw√¥': '·î∏', 'ywa': '·î∫', 'yw√¢': '·îº', 'th': '·ñÆ', 'th√™': '·ñß', 'thi': '·ñ®', 'th√Æ': '·ñ©', 'tho': '·ñ™', 'th√¥': '·ñ´', 'tha': '·ñ¨', 'th√¢': '·ñ≠', 'thw√™': '\u1677', 'thwi': '\u1678', 'thw√Æ': '\u1679', 'thwo': '\u167A', 'thw√¥': '\u167B', 'thwa': '\u167C', 'thw√¢': '\u167D', 'l': '·ì¨', 'r': '·ïí', 'h': '·ê¶', 'hk': '·ïΩ' }
  // Create the syllabics2sroLookup as the inverse of sro2syllabicsLookup
  const syllabics2sroLookup = (function () {
    var syl // IE11 doesn't handle `let` in for-loops properly :(
    let lookup = {}
    // IE11 also doesn't do for-of, so I need for-in, with the
    // ritual .hasOwnProperty() check :C
    for (var sro in sro2syllabicsLookup) {
      /* istanbul ignore if */
      if (!sro2syllabicsLookup.hasOwnProperty(sro)) {
        continue
      }
      syl = sro2syllabicsLookup[sro]

      lookup[syl] = sro
    }
    // Add a few alternate and lookalike characters to the lookup, as well as
    // the syllabics "hyphen".
    let alternates = {
      '·êù': 'y', '·ôÆ': '.', '·ë¶': 'm', '·ïÅ': 'hk', '·ïÄ': 'y', '\u202f': '-'
    }
    // Use for-in and .hasOwnProperty() check for IE11 compatibility üò°
    for (syl in alternates) {
      /* istanbul ignore else */
      if (alternates.hasOwnProperty(syl)) {
        lookup[syl] = alternates[syl]
      }
    }
    return lookup
  })()
  // Convert SYLLABIC + FINAL DOT into SYLLABIC WITH DOT
  const SYLLABIC_WITH_DOT = { '·êÅ': '·êç', '·êÉ': '·êè', '·êÑ': '·êë', '·êÖ': '·êì', '·êÜ': '·êï', '·êä': '·êò', '·êã': '·êö', '·êØ': '·êª', '·ê±': '·êΩ', '·ê≤': '·êø', '·ê≥': '·ëÅ', '·ê¥': '·ëÉ', '·ê∏': '·ëÖ', '·êπ': '·ëá', '·ëå': '·ëò', '·ëé': '·ëö', '·ëè': '·ëú', '·ëê': '·ëû', '·ëë': '·ë†', '·ëï': '·ë¢', '·ëñ': '·ë§', '·ë´': '·ëµ', '·ë≠': '·ë∑', '·ëÆ': '·ëπ', '·ëØ': '·ëª', '·ë∞': '·ëΩ', '·ë≤': '·ëø', '·ë≥': '·íÅ', '·íâ': '·íì', '·íã': '·íï', '·íå': '·íó', '·íç': '·íô', '·íé': '·íõ', '·íê': '·íù', '·íë': '·íü', '·í£': '·í≠', '·í•': '·íØ', '·í¶': '·í±', '·íß': '·í≥', '·í®': '·íµ', '·í™': '·í∑', '·í´': '·íπ', '·ìÄ': '·ìä', '·ìá': '·ìå', '·ìà': '·ìé', '·ì≠': '·ì∑', '·ìØ': '·ìπ', '·ì∞': '·ìª', '·ì±': '·ìΩ', '·ì≤': '·ìø', '·ì¥': '·îÅ', '·ìµ': '·îÉ', '·î¶': '·î∞', '·î®': '·î≤', '·î©': '·î¥', '·î™': '·î∂', '·î´': '·î∏', '·î≠': '·î∫', '·îÆ': '·îº' }

  // A few character translation functions.
  const circumflexToMacrons = makeTranslation('√™√Æ√¥√¢', 'ƒìƒ´≈çƒÅ')
  const translateAltForms = makeTranslation("eƒì'‚Äôƒ´≈çƒÅ", '√™√™ii√Æ√¥√¢')
  const syllabicToSRO = makeTranslation(Object.keys(syllabics2sroLookup), (function values () {
    // Work around for lack of Object.values() on some platforms.
    var a = []
    var syl
    for (syl in syllabics2sroLookup) {
      if (syllabics2sroLookup.hasOwnProperty(syl)) {
        a.push(syllabics2sroLookup[syl])
      }
    }
    return a
  }()))

  // ========================= Primary Exports ========================= \\

  // EXPORT: Convert SRO to syllabics:
  function sro2syllabics (sro, options) {
    options = options || {}
    let hyphens = options.hyphens || DEFAULT_SRO2SYLLABICS_OPTIONS.hyphens

    let hk;
    switch (options.finalHK) {
      case "hk":
        hk = "·ê¶·ê†"
        break

      case "x":
      case undefined:
        hk = "·ïΩ"
        break

      default:
        throw new Error('final hk must be either "hk" or "x"')
    }

    // Instead of using sro2syllabicsLookup directly, create a customizable
    // lookup here that fallsback to sro2syllabicsLookup.
    let lookup = Object.create(sro2syllabicsLookup)
    // The customization is what the hyphen should be converted to:
    lookup['-'] = hyphens

    let transliteration = nfc(sro).replace(wordPattern, transliterateWord)
    return transliteration.replace(fullStopPattern, function (_, syllabic) {
      // The pattern may yank the last syllabic before the full stop,
      // so add it back here:
      return (syllabic || '') + '\u166E' // ·ôÆ U+166E CANADIAN SYLLABICS FULL STOP
    })

    function transliterateWord (_match, preamble, word) {
      // The pattern matches zero or more non-word characters before the word
      // (preamble), so glue that before the word.
      return (preamble || '') + transcodeSROWordToSyllabics(word)
    }

    function transcodeSROWordToSyllabics (sroWord) {
      let toTranscribe = translateAltForms(sroWord.toLowerCase())

      let parts = []
      let match = toTranscribe.match(sroPattern)

      while (match) {
        let syllable = match[0]
        let onset = match[1]
        let vowel = match[2]
        let nextSyllablePos

        if (onset !== undefined) {
          // When the onset matched, apply sandhi for Cw?-V ‚Üí Cw?V
          syllable = onset + vowel
          // Special case for sandhi hw?-V cases: Just transcribe
          // the 'h'/·ê¶ part first, then run pretend that this
          // syllable is just the (optional w and) vowel.
          if (onset[0] === 'h') {
            parts.push('·ê¶');
            syllable = syllable.substr(1);
          }
        }
        nextSyllablePos = match[0].length

        let syllabic = lookup[syllable]
        parts.push(syllabic)
        toTranscribe = toTranscribe.slice(nextSyllablePos)

        match = toTranscribe.match(sroPattern)
      }

      if (endsWithHK(parts)) {
        // Replace last two charcters with 'hk' syllabic
        parts = parts.slice(0, parts.length - 2).concat(hk)
      }

      return parts.join('')
    }
  }

  // EXPORT: Convert syllabics to SRO:
  function syllabics2sro (syllabics, options) {
    options = options || {}
    let longAccents = options.longAccents || DEFAULT_SYLLABICS2SRO_OPTIONS.longAccents

    var normalized = syllabics.replace(finalDotPattern, fixFinalDot)
    var sroString = syllabicToSRO(normalized)

    if (longAccents === 'macrons') {
      return circumflexToMacrons(sroString)
    }
    return sroString
  }

  // ========================= Helper functions ========================= \\

  /**
   * Returns the string in NFC Unicode normalization form.
   * This means latin characters with accents will always be precomposed, if
   * possible.
   */
  let nfc
  if (String.prototype.normalize instanceof Function) {
    // Use ES2015 String.prototype.normalize, if available.
    nfc = function nfcUsingNormalize (string) {
      return string.normalize('NFC')
    }
  } else {
    // Otherwise, ONLY decompose some selected decomposed characters
    // Table generated by: libexec/generate-replacement.py
    const decomposed2nfc = { 'E\u0302': '\xca', 'E\u0304': '\u0112', 'e\u0302': '\xea', 'e\u0304': '\u0113', 'I\u0302': '\xce', 'I\u0304': '\u012a', 'i\u0302': '\xee', 'i\u0304': '\u012b', 'O\u0302': '\xd4', 'O\u0304': '\u014c', 'o\u0302': '\xf4', 'o\u0304': '\u014d', 'A\u0302': '\xc2', 'A\u0304': '\u0100', 'a\u0302': '\xe2', 'a\u0304': '\u0101' }
    nfc = function selectiveNFC (string) {
      return string.replace(/[aeio][\u0302\u0304]/gi, function (sequence) {
        return decomposed2nfc[sequence]
      })
    }
  }

  /**
   * Returns whether the array ends with ·ê¶·ê†
   */
  function endsWithHK (parts) {
    let n = parts.length
    return parts[n - 1] === '·ê†' && parts[n - 2] === '·ê¶'
  }

  /**
   * Converts a syllabic into its w-dotted equivilent.
   */
  function fixFinalDot (match) {
    return SYLLABIC_WITH_DOT[match[0]]
  }

  /**
   * Returns a function that translates cooresponding code units from string 1
   * to string 2.
   * Like Unix tr(1).
   */
  function makeTranslation (original, replacement) {
    let translation = new Map()
    Array.prototype.forEach.call(original, function setMap (source, index) {
      translation.set(source, replacement[index] || '')
    })

    return function (string) {
      return Array.prototype.map.call(string, function replace (ch) {
        return translation.has(ch) ? translation.get(ch) : ch
      }).join('')
    }
  }

  /* istanbul ignore next */
  if (typeof module !== 'undefined') {
    /* Export for Node/CommonJS */
    module.exports = exports
  } else if (typeof window !== 'undefined') {
    /* Export for browsers */
    window.CreeSROSyllabics = exports
  }
}())

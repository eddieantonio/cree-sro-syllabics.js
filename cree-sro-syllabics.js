/*
 * Copyright (C) 2018 Eddie Antonio Santos <easantos@ualberta.ca>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

(function () {
  // EXPORT: version
  const VERSION = '2018.11.13'

  // What functions and constants to export:
  let exports = {
    sro2syllabics,
    syllabics2sro,
    version: VERSION
  }

  // ============================ Constants ============================ \\

  // Default options for sro2syllabics() and syllabics2sro
  const DEFAULT_SRO2SYLLABICS_OPTIONS = {
    hyphens: '\u202f' // U+202F NARROW NO-BREAK SPACE, preferred by syllabics writers
  }
  const DEFAULT_SYLLABICS2SRO_OPTIONS = {
    longAccents: 'circumflexes'
  }

  // Word and syllable matching regular expressions.
  const STRICT_VOWEL = '[êioaîôâ]'
  const VOWEL = `${STRICT_VOWEL}|[eēī'ōā]`
  // NOTE: autogenerated by ./libexec/generate-regexp.py
  const sroPattern = /((?:[ptkcshmnyw]|th)w?)-([\u00EAioa\u00EE\u00F4\u00E2])|th\u00EA|thi|tho|tha|th\u00EE|th\u00F4|th\u00E2|th|w\u00EA|wi|wo|wa|w\u00EE|w\u00F4|w\u00E2|w|p\u00EA|pi|po|pa|p\u00EE|p\u00F4|p\u00E2|pw\u00EA|pwi|pwo|pwa|pw\u00EE|pw\u00F4|pw\u00E2|p|t\u00EA|ti|to|ta|t\u00EE|t\u00F4|t\u00E2|tw\u00EA|twi|two|twa|tw\u00EE|tw\u00F4|tw\u00E2|t|k\u00EA|ki|ko|ka|k\u00EE|k\u00F4|k\u00E2|kw\u00EA|kwi|kwo|kwa|kw\u00EE|kw\u00F4|kw\u00E2|k|c\u00EA|ci|co|ca|c\u00EE|c\u00F4|c\u00E2|cw\u00EA|cwi|cwo|cwa|cw\u00EE|cw\u00F4|cw\u00E2|c|m\u00EA|mi|mo|ma|m\u00EE|m\u00F4|m\u00E2|mw\u00EA|mwi|mwo|mwa|mw\u00EE|mw\u00F4|mw\u00E2|m|n\u00EA|ni|no|na|n\u00EE|n\u00F4|n\u00E2|nw\u00EA|nwa|nw\u00E2|n|s\u00EA|si|so|sa|s\u00EE|s\u00F4|s\u00E2|sw\u00EA|swi|swo|swa|sw\u00EE|sw\u00F4|sw\u00E2|s|y\u00EA|yi|yo|ya|y\u00EE|y\u00F4|y\u00E2|yw\u00EA|ywi|ywo|ywa|yw\u00EE|yw\u00F4|yw\u00E2|y|h|l|r|\u00EA|i|\u00EE|o|\u00F4|a|\u00E2|-/
  const WORD_INITIAL = `
      [ptkcmnsyh]w? |
      (?:th|[rl]) |
      w |
  `
  const WORD_MEDIAL = `
      (?:[hsmnwy]|th)? (?:[ptkcmnsyh]|th) w? |
      w |
      [yw]? [rl]
  `
  const WORD_FINAL = `
      [hs]? (?:[ptcksmnwy]|th) |
      [yw]? [rl] |
  `
  const CODA = 'th|[hs]?[ptkcmn]|h|s|y|w'
  const MORPHEME = `
      (?:${WORD_INITIAL}) (?:${VOWEL})
          (?: (?:${WORD_MEDIAL}) (?:${VOWEL}) )*
      (?:${WORD_FINAL})
  `
  // Matches the beginning of a Cree SRO word. Use this instead of \b!
  const BEGIN_WORD = `
  (?:
          ^
          |
          (?<=[^a-zêioaîôâeēī'ōā])
  )
  `
  // Matches the end of a Cree SRO word. Use this instead of \b!
  const END_WORD = `
  (?:
          (?=[^a-zêioaîôâeēī'ōā]) |
          $
  )
  `
  const wordPattern = new RegExp(verboseRegExp`
      ${BEGIN_WORD} ${MORPHEME} (?: (?:${CODA})?-${MORPHEME})* ${END_WORD}
  `, 'gi')
  // Matches a full stop at the end of a Cree word, or in isolation.
  const fullStopPattern = verboseRegExp`
      (?<=[\\u1400-\\u167f])[.] |
      ^.$
  `

  // Lookup tables:
  const sro2syllabicsLookup = { 'ê': 'ᐁ', 'i': 'ᐃ', 'î': 'ᐄ', 'o': 'ᐅ', 'ô': 'ᐆ', 'a': 'ᐊ', 'â': 'ᐋ', 'wê': 'ᐍ', 'wi': 'ᐏ', 'wî': 'ᐑ', 'wo': 'ᐓ', 'wô': 'ᐕ', 'wa': 'ᐘ', 'wâ': 'ᐚ', 'w': 'ᐤ', 'p': 'ᑊ', 'pê': 'ᐯ', 'pi': 'ᐱ', 'pî': 'ᐲ', 'po': 'ᐳ', 'pô': 'ᐴ', 'pa': 'ᐸ', 'pâ': 'ᐹ', 'pwê': 'ᐻ', 'pwi': 'ᐽ', 'pwî': 'ᐿ', 'pwo': 'ᑁ', 'pwô': 'ᑃ', 'pwa': 'ᑅ', 'pwâ': 'ᑇ', 't': 'ᐟ', 'tê': 'ᑌ', 'ti': 'ᑎ', 'tî': 'ᑏ', 'to': 'ᑐ', 'tô': 'ᑑ', 'ta': 'ᑕ', 'tâ': 'ᑖ', 'twê': 'ᑘ', 'twi': 'ᑚ', 'twî': 'ᑜ', 'two': 'ᑞ', 'twô': 'ᑠ', 'twa': 'ᑢ', 'twâ': 'ᑤ', 'k': 'ᐠ', 'kê': 'ᑫ', 'ki': 'ᑭ', 'kî': 'ᑮ', 'ko': 'ᑯ', 'kô': 'ᑰ', 'ka': 'ᑲ', 'kâ': 'ᑳ', 'kwê': 'ᑵ', 'kwi': 'ᑷ', 'kwî': 'ᑹ', 'kwo': 'ᑻ', 'kwô': 'ᑽ', 'kwa': 'ᑿ', 'kwâ': 'ᒁ', 'c': 'ᐨ', 'cê': 'ᒉ', 'ci': 'ᒋ', 'cî': 'ᒌ', 'co': 'ᒍ', 'cô': 'ᒎ', 'ca': 'ᒐ', 'câ': 'ᒑ', 'cwê': 'ᒓ', 'cwi': 'ᒕ', 'cwî': 'ᒗ', 'cwo': 'ᒙ', 'cwô': 'ᒛ', 'cwa': 'ᒝ', 'cwâ': 'ᒟ', 'm': 'ᒼ', 'mê': 'ᒣ', 'mi': 'ᒥ', 'mî': 'ᒦ', 'mo': 'ᒧ', 'mô': 'ᒨ', 'ma': 'ᒪ', 'mâ': 'ᒫ', 'mwê': 'ᒭ', 'mwi': 'ᒯ', 'mwî': 'ᒱ', 'mwo': 'ᒳ', 'mwô': 'ᒵ', 'mwa': 'ᒷ', 'mwâ': 'ᒹ', 'n': 'ᐣ', 'nê': 'ᓀ', 'ni': 'ᓂ', 'nî': 'ᓃ', 'no': 'ᓄ', 'nô': 'ᓅ', 'na': 'ᓇ', 'nâ': 'ᓈ', 'nwê': 'ᓊ', 'nwa': 'ᓌ', 'nwâ': 'ᓎ', 's': 'ᐢ', 'sê': 'ᓭ', 'si': 'ᓯ', 'sî': 'ᓰ', 'so': 'ᓱ', 'sô': 'ᓲ', 'sa': 'ᓴ', 'sâ': 'ᓵ', 'swê': 'ᓷ', 'swi': 'ᓹ', 'swî': 'ᓻ', 'swo': 'ᓽ', 'swô': 'ᓿ', 'swa': 'ᔁ', 'swâ': 'ᔃ', 'y': 'ᕀ', 'yê': 'ᔦ', 'yi': 'ᔨ', 'yî': 'ᔩ', 'yo': 'ᔪ', 'yô': 'ᔫ', 'ya': 'ᔭ', 'yâ': 'ᔮ', 'ywê': 'ᔰ', 'ywi': 'ᔲ', 'ywî': 'ᔴ', 'ywo': 'ᔶ', 'ywô': 'ᔸ', 'ywa': 'ᔺ', 'ywâ': 'ᔼ', 'th': 'ᖮ', 'thê': 'ᖧ', 'thi': 'ᖨ', 'thî': 'ᖩ', 'tho': 'ᖪ', 'thô': 'ᖫ', 'tha': 'ᖬ', 'thâ': 'ᖭ', 'l': 'ᓬ', 'r': 'ᕒ', 'h': 'ᐦ', 'hk': 'ᕽ' }
  // Create the syllabics2sroLookup as the inverse of sro2syllabicsLookup
  const syllabics2sroLookup = (function () {
    let lookup = {}
    for (var [sro, syl] of Object.entries(sro2syllabicsLookup)) {
      lookup[syl] = sro
    }
    // Add a few alternate and lookalike characters to the lookup, as well as
    // the syllabics "hyphen".
    Object.assign(lookup, {
      'ᐝ': 'y', '᙮': '.', 'ᑦ': 'm', 'ᕁ': 'hk', 'ᐩ': 'y', '\u202f': '-'
    })
    return lookup
  })()
  const SYLLABIC_WITH_DOT = { 'ᐁ': 'ᐍ', 'ᐃ': 'ᐏ', 'ᐄ': 'ᐑ', 'ᐅ': 'ᐓ', 'ᐆ': 'ᐕ', 'ᐊ': 'ᐘ', 'ᐋ': 'ᐚ', 'ᐯ': 'ᐻ', 'ᐱ': 'ᐽ', 'ᐲ': 'ᐿ', 'ᐳ': 'ᑁ', 'ᐴ': 'ᑃ', 'ᐸ': 'ᑅ', 'ᐹ': 'ᑇ', 'ᑌ': 'ᑘ', 'ᑎ': 'ᑚ', 'ᑏ': 'ᑜ', 'ᑐ': 'ᑞ', 'ᑑ': 'ᑠ', 'ᑕ': 'ᑢ', 'ᑖ': 'ᑤ', 'ᑫ': 'ᑵ', 'ᑭ': 'ᑷ', 'ᑮ': 'ᑹ', 'ᑯ': 'ᑻ', 'ᑰ': 'ᑽ', 'ᑲ': 'ᑿ', 'ᑳ': 'ᒁ', 'ᒉ': 'ᒓ', 'ᒋ': 'ᒕ', 'ᒌ': 'ᒗ', 'ᒍ': 'ᒙ', 'ᒎ': 'ᒛ', 'ᒐ': 'ᒝ', 'ᒑ': 'ᒟ', 'ᒣ': 'ᒭ', 'ᒥ': 'ᒯ', 'ᒦ': 'ᒱ', 'ᒧ': 'ᒳ', 'ᒨ': 'ᒵ', 'ᒪ': 'ᒷ', 'ᒫ': 'ᒹ', 'ᓀ': 'ᓊ', 'ᓇ': 'ᓌ', 'ᓈ': 'ᓎ', 'ᓭ': 'ᓷ', 'ᓯ': 'ᓹ', 'ᓰ': 'ᓻ', 'ᓱ': 'ᓽ', 'ᓲ': 'ᓿ', 'ᓴ': 'ᔁ', 'ᓵ': 'ᔃ', 'ᔦ': 'ᔰ', 'ᔨ': 'ᔲ', 'ᔩ': 'ᔴ', 'ᔪ': 'ᔶ', 'ᔫ': 'ᔸ', 'ᔭ': 'ᔺ', 'ᔮ': 'ᔼ' }

  // Convert SYLLABIC + FINAL DOT into SYLLABIC WITH DOT
  const finalDotPattern = (function () {
    let withoutDot = Object.keys(SYLLABIC_WITH_DOT).join('')
    return new RegExp(`([${withoutDot}])ᐧ`)
  }())

  // A few character translation functions.
  const circumflexToMacrons = makeTranslation('êîôâ', 'ēīōā')
  const translateAltForms = makeTranslation("eē'īōā", 'êêiîôâ')
  const syllabicToSRO = makeTranslation(Object.keys(syllabics2sroLookup), Object.values(syllabics2sroLookup))

  // ========================= Primary Exports ========================= \\

  // EXPORT: Convert SRO to syllabics:
  function sro2syllabics (sro, options = {}) {
    let hyphens = options.hyphens || DEFAULT_SRO2SYLLABICS_OPTIONS.hyphens
    // Instead of using sro2syllabicsLookup directly, create a customizable
    // lookup here that fallsback to sro2syllabicsLookup.
    let lookup = Object.create(sro2syllabicsLookup)
    // The customization is what the hyphen should be converted to:
    Object.assign(lookup, { '-': hyphens })

    let transliteration = nfc(sro).replace(wordPattern, transliterateWord)
    return transliteration.replace(fullStopPattern, '᙮')

    function transliterateWord (match) {
      return transcodeSROWordToSyllabics(match)
    }

    function transcodeSROWordToSyllabics (sroWord) {
      let toTranscribe = translateAltForms(sroWord.toLowerCase())

      let parts = []
      let match = toTranscribe.match(sroPattern)

      while (match) {
        let [syllable, onset, vowel] = match
        let nextSyllablePos

        if (onset !== undefined) {
          // When the onset matched, apply sandhi for Cw?-V → Cw?V
          syllable = onset + vowel
        }
        nextSyllablePos = match[0].length

        let syllabic = lookup[syllable]
        parts.push(syllabic)
        toTranscribe = toTranscribe.slice(nextSyllablePos)

        match = toTranscribe.match(sroPattern)
      }

      if (endsWithHK(parts)) {
        // Replace last two charcters with 'hk' syllabic
        parts = parts.slice(0, parts.length - 2).concat('ᕽ')
      }

      return parts.join('')
    }
  }

  // EXPORT: Convert syllabics to SRO:
  function syllabics2sro (syllabics, options = {}) {
    let longAccents = options.longAccents || DEFAULT_SYLLABICS2SRO_OPTIONS.longAccents

    var normalized = syllabics.replace(finalDotPattern, fixFinalDot)
    var sroString = syllabicToSRO(normalized)

    if (longAccents === 'macrons') {
      return circumflexToMacrons(sroString)
    }
    return sroString
  }

  // ========================= Helper functions ========================= \\

  /**
   * Returns the string in NFC Unicode normalization form.
   * This means latin characters with accents will always be precomposed, if
   * possible.
   */
  function nfc (string) {
    return string.normalize('NFC')
  }

  /**
   * Returns whether the array ends with ᐦᐠ
   */
  function endsWithHK (parts) {
    let n = parts.length
    return parts[n - 1] === 'ᐠ' && parts[n - 2] === 'ᐦ'
  }

  /**
   * Converts a syllabic into its w-dotted equivilent.
   */
  function fixFinalDot (match) {
    return SYLLABIC_WITH_DOT[match[0]]
  }

  /**
   * Returns a function that translates cooresponding code units from string 1
   * to string 2.
   * Like Unix tr(1).
   */
  function makeTranslation (original, replacement) {
    let translation = new Map()
    for (let [index, source] of Array.from(original).entries()) {
      translation.set(source, replacement[index] || '')
    }

    return function (string) {
      return Array.from(string).map(ch =>
        translation.has(ch) ? translation.get(ch) : ch
      ).join('')
    }
  }

  /**
   * Template tag for creating defining regular expressions with whitespace
   * and placeholders. Allows for (somewhat) more readable regexps.
   */
  function verboseRegExp (strings, ...placeholders) {
    let normalizedStrings = strings.map(removeWhitespace)
    let normalizedPlaceholders = placeholders.map(removeWhitespace)
    let regexpParts = []

    // there are always strings.length + 1 placeholders
    // the first string is either '' or the prefix
    regexpParts.push(normalizedStrings[0])
    // the last string is either '' or the suffix
    for (let [index, placeholder] of normalizedPlaceholders.entries()) {
      regexpParts.push(placeholder)
      regexpParts.push(normalizedStrings[index + 1])
    }

    return new RegExp(regexpParts.join(''))

    function removeWhitespace (string) {
      return string.replace(/\s/g, '')
    }
  }

  if (typeof module !== 'undefined') {
    /* Export for Node/CommonJS */
    module.exports = exports
  } else if (typeof window !== 'undefined') {
    /* Export for browsers */
    window.CreeSROSyllabics = exports
  }
}())
